<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>V2Config</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        /* --- Material Design 3 (Red Theme) --- */
        :root {
            --md-sys-color-background: #111318;
            --md-sys-color-surface: #191C20;
            --md-sys-color-surface-container: #201A1A;
            --md-sys-color-on-surface: #E2E2E6;
            --md-sys-color-on-surface-variant: #D0C4C4;
            --md-sys-color-primary: #FF1D10; 
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #93000A;
            --md-sys-color-on-primary-container: #FFDAD6;
            --md-sys-color-outline: #8E9099;
            --radius-lg: 16px;
            --bottom-bar-height: 80px;
        }

        body {
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            padding: 24px 16px;
            background-color: var(--md-sys-color-background);
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 1px solid rgba(255,29,16,0.1);
        }

        h1 { margin: 0; font-size: 22px; font-weight: 500; display: flex; align-items: center; gap: 10px; }

        .controls { padding: 16px; }

        .filter-card {
            background-color: var(--md-sys-color-surface-container);
            border-radius: var(--radius-lg);
            padding: 16px;
            border: 1px solid rgba(255,29,16,0.1);
        }

        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .toggle-row:last-child { margin-bottom: 0; }

        .toggle-label { font-size: 16px; }

        .switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 28px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #44474F;
            border-radius: 34px;
            transition: .3s;
            border: 2px solid var(--md-sys-color-outline);
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 5px;
            bottom: 5px;
            background-color: #AAABBB;
            border-radius: 50%;
            transition: .3s;
        }
        input:checked + .slider {
            background-color: var(--md-sys-color-primary);
            border-color: var(--md-sys-color-primary);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
            background-color: var(--md-sys-color-on-primary);
            width: 20px;
            height: 20px;
            left: 2px;
            bottom: 2px;
        }

        .list-container {
            flex: 1;
            padding: 0 16px var(--bottom-bar-height) 16px;
            overflow-y: auto;
        }

        .card {
            background-color: var(--md-sys-color-surface);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: background-color 0.2s;
            gap: 8px;
        }
        .card:active {
            background-color: var(--md-sys-color-surface-container);
        }

        .card-info {
            display: flex;
            align-items: center;
            gap: 12px;
            overflow: hidden;
            flex: 1;
            cursor: pointer;
        }

        .icon-box {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 29, 16, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--md-sys-color-primary);
            flex-shrink: 0;
        }

        .file-details {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            margin-right: 5px;
        }

        .file-name {
            font-size: 15px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-tag {
            font-size: 12px;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: 2px;
        }

        .actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: var(--md-sys-color-surface-container);
            color: var(--md-sys-color-primary);
            border: 1px solid rgba(255,29,16,0.2);
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .action-btn.download {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border: none;
            border-radius: 50%;
        }

        .action-btn:active { transform: scale(0.95); }
        
        .action-btn.loading { 
            pointer-events: none; 
            opacity: 0.8;
        }
        .action-btn.loading span { opacity: 0; }
        .action-btn.loading::after {
            content: "";
            position: absolute;
            width: 18px;
            height: 18px;
            border: 2px solid currentColor;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 16px;
            background: linear-gradient(to top, var(--md-sys-color-background) 80%, transparent);
            display: flex;
            justify-content: center;
            z-index: 100;
        }

        .download-all-btn {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            height: 56px;
            border-radius: 28px;
            padding: 0 32px;
            font-size: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            cursor: pointer;
            width: 100%;
            max-width: 400px;
            justify-content: center;
            transition: transform 0.2s;
        }
        .download-all-btn:active { transform: scale(0.98); }

        .toast {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background-color: #303030;
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 200;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .msg-box {
            text-align: center;
            margin-top: 40px;
            color: var(--md-sys-color-on-surface-variant);
            padding: 20px;
            background: rgba(255,29,16,0.05);
            border-radius: 12px;
        }
        .msg-sub {
            font-size: 12px;
            margin-top: 8px;
            opacity: 0.7;
        }

        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <header>
    </header>

    <div class="controls">
        <div class="filter-card">
            <div class="toggle-row">
                <span class="toggle-label">Whitelist (Белый список)</span>
                <label class="switch">
                    <input type="checkbox" id="checkWhite" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-row">
                <span class="toggle-label">Blacklist (Черный список)</span>
                <label class="switch">
                    <input type="checkbox" id="checkBlack" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>

    <div id="list" class="list-container">
        <!-- JS Injection -->
    </div>

    <div class="bottom-bar" id="bottomBar">
        <button class="download-all-btn" id="btnDownloadAll" onclick="downloadAllVisible()">
            <span class="material-symbols-rounded">folder_zip</span>
            Скачать всё (ZIP)
        </button>
    </div>

    <div id="toast" class="toast">Текст уведомления</div>

    <script>
        const REPO = 'igareck/vpn-configs-for-russia';
        const API = `https://api.github.com/repos/${REPO}/contents/`;

        // --- АГРЕССИВНАЯ ПРОВЕРКА IN-APP BROWSER (ТЕЛЕГРАМ) ---
        const ua = navigator.userAgent.toLowerCase();

        // 1. Поиск явных названий мессенджеров
        const isMessenger = ua.includes('telegram') || ua.includes('instagram') || ua.includes('vk');
        
        // 2. Поиск признаков Android WebView (используется телеграмом на Android)
        // Обычный Chrome: "Android ... Chrome/..."
        // Встроенный WebView часто имеет: "...; wv) ..." ИЛИ "... Version/4.0 Chrome/..."
        const isAndroidWebView = /wv/.test(ua) || (ua.includes('android') && ua.includes('version/'));

        // 3. iOS PWA / Webview
        const isIosStandalone = window.navigator.standalone === true;

        // Если это мессенджер, WebView или PWA - считаем, что скачивать нельзя
        // !isAndroidWebView - это самое важное изменение, оно отсечет Telegram на Xiaomi
        const CAN_DOWNLOAD = !isMessenger && !isAndroidWebView && !isIosStandalone;

        let rawFiles = [];
        let currentVisibleFiles = [];
        
        const elList = document.getElementById('list');
        const swWhite = document.getElementById('checkWhite');
        const swBlack = document.getElementById('checkBlack');
        const toastEl = document.getElementById('toast');
        const btnDownloadAll = document.getElementById('btnDownloadAll');
        const bottomBar = document.getElementById('bottomBar');

        // Инициализация
        (async () => {
            
            // Если скачивание запрещено (обнаружен WebView), скрываем интерфейс загрузки
            if (!CAN_DOWNLOAD) {
                if (bottomBar) bottomBar.style.display = 'none';
                elList.style.paddingBottom = '20px'; 
                document.documentElement.style.setProperty('--bottom-bar-height', '0px');
                toastEl.style.bottom = '30px'; 
            }

            elList.innerHTML = '<div class="msg-box">Загрузка списка конфигураций...</div>';
            try {
                const res = await fetch(API);
                if(!res.ok) throw new Error();
                const data = await res.json();
                
                rawFiles = data.filter(f => 
                    f.type === 'file' && 
                    f.name.toLowerCase().includes('mobile')
                );
                
                render();
            } catch (e) {
                elList.innerHTML = `
                    <div class="msg-box">
                        Ошибка доступа к GitHub API.
                        <div class="msg-sub">Попробуйте включить любой VPN для первого обновления списка.</div>
                    </div>`;
            }
        })();

        // События
        swWhite.onchange = render;
        swBlack.onchange = render;

        function render() {
            elList.innerHTML = '';
            
            const showW = swWhite.checked;
            const showB = swBlack.checked;

            currentVisibleFiles = rawFiles.filter(f => {
                const n = f.name.toLowerCase();
                const isW = n.includes('white');
                const isB = n.includes('black');
                if (isW && showW) return true;
                if (isB && showB) return true;
                return false;
            });

            // Логика отображения кнопки "Скачать всё"
            if (CAN_DOWNLOAD) {
                if (currentVisibleFiles.length === 0) {
                    btnDownloadAll.style.opacity = '0.5';
                    btnDownloadAll.style.pointerEvents = 'none';
                    elList.innerHTML = '<div class="msg-box">Нет конфигураций для выбранных фильтров</div>';
                    return;
                } else {
                    btnDownloadAll.style.opacity = '1';
                    btnDownloadAll.style.pointerEvents = 'auto';
                }
            } else if (currentVisibleFiles.length === 0) {
                elList.innerHTML = '<div class="msg-box">Нет конфигураций для выбранных фильтров</div>';
                return;
            }

            currentVisibleFiles.forEach(f => {
                const item = document.createElement('div');
                item.className = 'card';
                
                let type = 'VPN';
                let icon = 'vpn_lock';
                if(f.name.includes('ovpn')) { type = 'OpenVPN'; icon = 'lock_open'; }
                if(f.name.includes('conf')) { type = 'WireGuard'; icon = 'router'; }

                const cleanName = f.name
                    .replace('antizapret-', '')
                    .replace('-mobile', '')
                    .replace('.ovpn', '')
                    .replace('.conf', '');

                // Кнопка скачивания только если CAN_DOWNLOAD = true
                const downloadBtnHtml = CAN_DOWNLOAD ? `
                    <button class="action-btn download" onclick="downloadSecure(this, '${f.download_url}', '${f.name}')" title="Скачать файл">
                        <span class="material-symbols-rounded">download</span>
                    </button>
                ` : '';

                item.innerHTML = `
                    <div class="card-info" onclick="copyContent(this.nextElementSibling.querySelector('.copy-btn'), '${f.download_url}')">
                        <div class="icon-box">
                            <span class="material-symbols-rounded">${icon}</span>
                        </div>
                        <div class="file-details">
                            <div class="file-name" title="${f.name}">${cleanName}</div>
                            <div class="file-tag">${type}</div>
                        </div>
                    </div>
                    <div class="actions">
                        <button class="action-btn copy-btn" onclick="copyContent(this, '${f.download_url}')" title="Копировать содержимое">
                            <span class="material-symbols-rounded">content_copy</span>
                        </button>
                        ${downloadBtnHtml}
                    </div>
                `;
                elList.appendChild(item);
            });
        }

        async function copyContent(btn, url) {
            if(btn.classList.contains('loading')) return;
            const originalIcon = btn.innerHTML;
            btn.classList.add('loading');

            try {
                const response = await fetch(url);
                if(!response.ok) throw new Error('Ошибка сети');
                const text = await response.text();

                await navigator.clipboard.writeText(text);

                btn.classList.remove('loading');
                btn.innerHTML = '<span class="material-symbols-rounded">check</span>';
                showToast('Скопировано в буфер!');

                setTimeout(() => {
                    btn.innerHTML = '<span class="material-symbols-rounded">content_copy</span>';
                }, 2000);

            } catch (err) {
                console.error(err);
                btn.classList.remove('loading');
                showToast('Ошибка копирования');
            }
        }

        async function downloadAllVisible() {
            if (!CAN_DOWNLOAD) return;
            if (currentVisibleFiles.length === 0) return;

            const btnText = btnDownloadAll.innerHTML;
            btnDownloadAll.innerHTML = '<span class="material-symbols-rounded">hourglass_top</span> Упаковка...';
            btnDownloadAll.style.pointerEvents = 'none';

            try {
                const zip = new JSZip();
                const promises = currentVisibleFiles.map(async file => {
                    try {
                        const response = await fetch(file.download_url);
                        if (!response.ok) throw new Error(`Fail ${file.name}`);
                        const blob = await response.blob();
                        zip.file(file.name, blob);
                    } catch (e) {
                        console.error(e);
                    }
                });

                await Promise.all(promises);
                const content = await zip.generateAsync({type:"blob"});
                const blobUrl = window.URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = "vpn_configs_red.zip";
                document.body.appendChild(link);
                link.click();
                
                setTimeout(() => {
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(blobUrl);
                }, 1000);
                
                showToast('Архив скачан!');

            } catch (err) {
                console.error(err);
                showToast('Ошибка при создании архива');
            } finally {
                btnDownloadAll.innerHTML = btnText;
                btnDownloadAll.style.pointerEvents = 'auto';
            }
        }

        async function downloadSecure(btn, url, fileName) {
            if (!CAN_DOWNLOAD) return;
            if(btn.classList.contains('loading')) return;
            btn.classList.add('loading');
            
            try {
                const response = await fetch(url);
                if(!response.ok) throw new Error('Network error');
                const blob = await response.blob();
                const newBlob = new Blob([blob], { type: 'application/octet-stream' });
                const blobUrl = window.URL.createObjectURL(newBlob);
                
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = fileName;
                link.target = "_blank"; 
                
                document.body.appendChild(link);
                link.click();
                
                setTimeout(() => {
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(blobUrl);
                    btn.classList.remove('loading');
                }, 2000);
                
            } catch (err) {
                console.error(err);
                btn.classList.remove('loading');
                if(confirm('Не удалось скачать скрыто. Открыть ссылку напрямую?')) {
                    window.open(url, '_blank');
                }
            }
        }

        let toastTimeout;
        function showToast(msg) {
            toastEl.textContent = msg;
            toastEl.classList.add('show');
            clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                toastEl.classList.remove('show');
            }, 3000);
        }
    </script>
</body>
</html>

